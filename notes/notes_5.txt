map function:
------------
map(function_to_apply, list_of_inputs)

Example
>>> items = [1, 2, 3, 4, 5]
>>> squared = list(map(lambda x: x**2, items))
>>> squared
[1, 4, 9, 16, 25]
>>>

Python iterables must implement one special methods, __iter__(). 
the "__iter__" magic function is called, for example, 
when a for-loop starts or run a function like list.

Python iterator object must implement two special methods, 
__iter__() and __next__().

An object is called iterable if we can get an iterator from it. 
Most of built-in containers in Python like: list, tuple, string 
etc. are iterables.

The iter() function (which in turn calls the __iter__() method) 
returns an iterator from them.
-------------

Range and RangeIterator: 
------------------------
In RangeIteratorT we see that range_iterator_class and 
range_iterator_function are imported meaning we 
can implement the rangeIterator functionality in 
both a class and a function.
 
In RangeT we see that range_1, and range_2 are imported. 
More importantly on lines 50-51 list() is called twice 
and we get a new iterator both times! This logic can't be 
done in a function, meaning we need to make a class that responds to __iter__().

 
Range_2:
-------
Range_2 in Range.py is trying to implement a range function that is not exhaustible. 
This is can be easily achieved by not updating the instance variables b and e.
Instead you create two local variables and update them. Doing this, will keep the 
original b and e as they were when the object was initially created, and therefore,
each time you list the object, you get the same sequence of numbers (i.e., not exhaustibale).

Note that a range object is an iterable but not iterator
>>> x = range(4)
>>> hasattr(x, "__iter__")
True
>>> hasattr(x, "__next__")
False
>>> 

Range_1:
-------
Rabge_1 in Range.py accomplishes the same outcome of Range_2 but using inner classes.
Inner class is a class that is defined inside another class. 
Whenever you create an object of Range_1, you need to pass two variables, namely b and e.
Afterward, whenever you try to navigate this object, You'll get an 
instance of the inner class with the original variable values. 
------

Note:
#Given an iterable, x, using "if x" does not work for user-defined iterables. 
# Example.
class iterable: 
      def __iter__(self): 
          return iter([])
          
x = iterable()
if x :
   print("full")
else :
   print("empty")
# full

def a_for (x) :
   for a in x :
      print("inside for")

def a_while (x) :
    p = iter(x)
    try :
        while True :
            w = next(p)
            print("inside while")
    except StopIteration :
        pass

x = iterable()
a_for(x)
a_while(x)
cycle_for(x)
------------

Recall:
Iterable object: type of objects which can be used with a for loop.
Iterator vs generator:
•	iterable object: an object that you can iterate through.
•	iterables usually have the property "__getitem__" that indicates an object is indexable.
•	iterator object: an object that has the "__iter__" attribute.
•	you can get an iterator out of an iterable using iter function.
•	Generator: is a function that produces a sequence of results instead of a single value.
•	every generator is an iterator.

Notes on iterables and iterators:
1) You cannot use len() to check if an iterable is empty (len(iterable) == 0). 
The function len() can be used on lists but not on iterable objects in general:

b = iter([1,2,3]) # b is both an iterator and an iterable.
len(b) # TypeError: object of type 'list_iterator' has no len()

b = iter([1,2,3])
assert list(filter(lambda x: x % 2 == 0, b)) == [2] # this works for the real filter

2) You cannot compare an iterable to the empty list (iterable == []) while iterable can be tuples, sets, ...

3) You cannot convert the iterable to a list (list(iterable) == []). 
This works for all finite iterable objects but won't work for infinite iterable objects (such as in count or repeat).

4) You cannot use next() on an iterable. The function next() can be used on an iterator but not on an iterable:

a = [1,2,3]
next(a) # TypeError: 'list' object is not an iterator
assert next(iter(a)) == 1 # this works
