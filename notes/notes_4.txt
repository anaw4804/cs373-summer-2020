Reduce.py:
---------
reduce:
------
- reduce is a higher order function. it takes a function 
  as one of its argument.
- mul is a function from a module called operator. 
  You can think of it as a wrapper for the operator '*'.
- reduce(binary_function, sequence_of_elements[, Seed: base_case_if_seq_is_empty)]

- Note that the initialization is optional. If it's present, 
  it will be placed before the items of the iterable in the calculations. 
  if it's not, and the iterable contain one item, it will return this one item.

  reduce_for_range (bf, a, v) demands a to be indexable.
  reduce_for (bf, a, v) does NOT demand a to indexable. It should only be iterable.
 
  reduce(add,[],0] #0
  reduce(add,[])
  error: no initial value

  e.g., reduce(mul, range(1, 4), 1)
  1*1*2*3
  e.g., reduce(add, range(1,5), 1) = 1 + 1 + 2 + 3 + 4 

  write the function reduce: reduce(bf, iterable, seed) 
-------------


iteration.py: 
------------
Iterables:
- an iterable is an object that you can iterate through.
- iterables usually have the property "__getitem__" 
  that indicates an object is indexable.

>>> x=[2, 3, 4]
>>> hasattr(x, "__iter__")
True
>>> hasattr(x, "__getitem__")
True
>>> hasattr(x, "__next__")
False

Iterators vs generators:
- an iterator object is an object that has the "__iter__" and "__next__" attribute.
- you can get an iterator out of an iterable using iter function.
- a Generator is a function that produces 
  a sequence of results instead of a single value.
- every generator is an iterator.

iter(): takes an iterable object and returns an iterator.
>>> x=[2, 3, 4]
>>> p = iter(x)
>>> next(p)
2
>>> next(p)
3
>>> next(p)
4
>>> next(p)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>>
-----
Notes:

1. Use len() to check if an iterable is empty (len(iterable) == 0). 
The function len() can be used on lists but not on iterable objects in general:
 
b = iter([1,2,3]) # b is both an iterator and an iterable.
len(b) # TypeError: object of type 'list_iterator' has no len()

b = iter([1,2,3])
assert list(filter(lambda x: x % 2 == 0, b)) == [2] # this works for the real filter

2. A common mistake is to compare the iterable to the empty list (iterable == []) 
while iterable can be tuples, sets, ...

3. Another common one is to convert the iterable to a list (list(iterable) == []). 
This works for all finite iterable objects but won't work for infinite iterable objects 
(such as in count or repeat).

4. it's wrong to use next() on an iterable. The function next() can be used 
on an iterator but not on an iterable:

a = [1,2,3]
next(a) # TypeError: 'list' object is not an iterator
assert next(iter(a)) == 1 # this works

5. Testing if an iterator is empty using "if x", where x is an iterator is wrong.

x = iter([1, 2])
# testing whether the iterator x is empty using "if x" will use up the elements of x
if x :
   print("x is not empty and it has the following values".format(list(x)))

Output: x is not empty and it has the following values

----
Generators:
yield:
------
Yield:
e.g., 1
>>>def f() :
>>>    print("abc")
>>>    return 5
>>>    print ("def") # it does not make sense to have code 
                     # after return unless there is a condition before return.

>>>v = f()
abc
>>>print(v)
5
-------------------------------
e.g., 2
>>>def f() :
>>>    print("abc")
>>>    yield 5
>>>    print("def")
>>>    yield 6

>>>v = f()
>>>print(v)
<generator object f at 0x0096E8A0>
>>>print(hasattr(v, "__next__"))
True
>>>w = next(v)
abc
>>>print(w)
5
>>>w = next(v) # function starts running from where it left off
def
>>>print(w)
6
>>> w = next(v) # raises an exception
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>>print(w)
6
------------------------------------------

>>>def f () :
>>>	print("abc")
>>>	yield 5
>>>	print("def")
>>>	yield 6
>>>	print("ghi")

>>>v = f()     # <nothing>
>>>print(v)    
<generator object f at .....>
>>>w = next(v) 
abc
>>>print(w)    
5
>>>x = next(v) 
def
>>>print(x)   
6
>>>y = next(v) 
ghi 
raise StopIteration
---------

Example of a Generator
# f.py
def yrange(n):
	i = 0
	while i < n :
		yield i
		i += 1
		
>>> from f import yrange
>>> yrange(3)
<generator object yrange at 0x01ABEA80>
>>> list(yrange(3))
[0, 1, 2]
>>>
------------------------------------------------------
Lambda and zip
--------------
Lambda is an anonymous function that can be created at runtime. 
Anonymous means that it should not be bound to a name.

>>> def f (x):
...     return x**2
>>> g = lambda x: x**2
>>>
>>> f(3) == g(3)
True
Note that the lambda definition does not include a "return" statement -- 
it always contains an expression which is returned.

Syntax:
lambda arg1, arg2, ...argN : expression using arguments
>>> f = lambda x, y, z: x + y + z
>>> f(1, 2, 3)
6
>>>

Zip:
zip is a generator that combines two objects in a tuple.

>>> a = [1, 2, 3, 4]
>>> b = ['a', 'b', 'c', 'd']
>>> c = zip(a, b)
>>> c
<zip object at 0x01939440>
>>> list(c)
[(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]
>>> list(c)
[]

Comprehensions.py
-----------------
filter(predicate, list_of_inputs)
filter is a generator takes a predicate, it applies the predicate 
on the given iterable returns the element that satisfies the predicate.
It's an iterator, i.e., it returns itself.


"|=" union of sets

Lines 174: all() # all(iterable): Return True if all elements of the iterable are true (or if the iterable is empty).
A(): instance of a class
True
...
all([]) = True

Lines 186: any() # any(iterable): Return True if any element of the iterable is true. If the iterable is empty, return False.
any([]) = False
https://docs.python.org/3.5/library/functions.html#all